"use strict"

// node built-ins
const fs = require("fs")
// npm libraries
const mongoose = require("mongoose")
const bunyan = require("bunyan")
const redis = require("redis")
const restify = require("restify")
const stripeLib = require("stripe")
// library code
const CORS = require("../lib/CORS")
const session = require("../lib/session")
const libredis = require("../lib/libredis")
const makeLogger = require("../lib/makeLogger.js")
const { initGoogleOAuthClient } = require("../lib/oauth/googleOAuthClient.js")
const { initMSALConfig } = require("../lib/oauth/microsoftOAuthClients.js")
// models
const User = (/** @type {UserClass} */ ((/** @type {unknown} */ (require("../models/User")))))


/**
 * @param {serverOptions} opts
 * @param {Function} [callback]
 */
async function apiServerStart(opts, callback) {
    if (opts.debug) global.DEBUG = true

    // Load environments & settings
    const config = require("../lib/environment")(opts.env)
    const settings = require("../config/settings")


    // If we have a port passed as env variable LISTEN_PORT, overwrite the one in the config file
    if (process.env.LISTEN_PORT) {
        config.server.port = process.env.LISTEN_PORT
    }

    // Change the number of max sockets (see: http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile )
    require("http").globalAgent.maxSockets = config.server.maxSockets
    require("https").globalAgent.maxSockets = config.server.maxSockets

    // Winston logger for application info
    const logger = makeLogger(config.logDirectory + "api/")

    // Bunyan logger for user events
    const userLog = new bunyan({
        name: "user.zapin",
        server: "api",
        port: config.server.port,
        streams: [
            /*{
                type: 'file',
                path: 'user-logs.txt',
                level: 'info'
            },*/
            {
                type: "stream",
                stream: process.stdout,
                level: "debug"
            }
        ],
        serializers: {
            // Return only certain fields for the user
            user: function (user) {
                const obj = {
                    id: user._id ? user._id.toString() : null,
                    email: user.email
                }
                if (user.displayName) {
                    obj.name = user.displayName
                
                } else if (user.name && (user.name.first || user.name.last)) {
                    obj.name = (user.name.first ? user.name.first + " " : "") +
                        user.name.last || ""
                }
                if (user.company) {
                    obj.company = user.company
                }
                if (!user.isMaster) {
                    if (user.populated && user.populated("masterAccount")) {
                        obj.masterAccount = user.masterAccount._id.toString()
                        obj.masterAccountEmail = user.masterAccount.email
                    
                    } else {
                        obj.masterAccount = user.masterAccount
                    }
                }
                return obj
            }
        }
    })
    logger.info(`Api server starting up...running on Node ${process.version}`)
 
    // Redis clients
    const apiServerRedisClient = redis.createClient({
        socket: {
            port: config.redis.port,
            host: config.redis.host
        },
        database: config.redis.dbApi
    })
    await apiServerRedisClient.connect()
    logger.info("Connected to redis for api server")
    await libredis.init(apiServerRedisClient)
    const microsoftOAuthRedisClient = redis.createClient({
        socket: {
            port: config.redis.port,
            host: config.redis.host
        },
        database: config.redis.dbMicrosoftOAuth
    })
    await microsoftOAuthRedisClient.connect()
    logger.info("Connected to redis for microsoft oauth")
    

    // Path for wkhtmltopdf if needed
    if (config.wkhtmltopdf) {
        require("wkhtmltopdf").command = config.wkhtmltopdf
    }

    // Read stripe config
    if (!config.stripe || !config.stripe.credentialsFile) {
        logger.error("Stripe not configured")
        return
    }
    const stripeCredentials = JSON.parse(fs.readFileSync(config.stripe.credentialsFile, "utf8"))
    if (stripeCredentials.publicKey.substring(3, 8) === "test_") {
        logger.info("Stripe: using test environment")
    }

    // Read intercom config
    if (!config.intercom || !config.intercom.credentialsFile) {
        logger.error("Path to file with Intercom Identity Verification key not found in config")
        return
    }
    const intercomConfig = JSON.parse(fs.readFileSync(config.intercom.credentialsFile, "utf8"))

    // Initialize LDIntl
    const LDIntl = require("../lib/LDIntl")
    LDIntl.defaultLocale = "en-US"
    LDIntl.allLanguages = ["en-US"]
    LDIntl.init()

    // Create the server
    const serverOpts = {
        name: "zapin",
        version: "2.0.0",
        onceNext: true
    }
    if (config.server.sslCert && config.server.sslKey) {
        // Enable SSL
        serverOpts.certificate = fs.readFileSync(config.server.sslCert)
        serverOpts.key = fs.readFileSync(config.server.sslKey)
    }
    const server = restify.createServer(serverOpts)

    // Save various config, settings, server session, logger, and library properties to the server object
    Object.assign(server, {
        appConfig: config,
        appSettings: settings,
        session: session,
        userLog: userLog,
        apiServerRedisClient: apiServerRedisClient,
        microsoftOAuthRedisClient: microsoftOAuthRedisClient,
        stripe: stripeLib(stripeCredentials.secretKey),
        mongoose: mongoose,
        logger: logger,
        intercom: intercomConfig
    })
    
    initGoogleOAuthClient(server.appConfig)
    await initMSALConfig(server.appConfig, microsoftOAuthRedisClient)

    // Some builtin (restify) middleware
    server.pre(restify.pre.sanitizePath()) // Sanitize paths like //foo/////bar// to /foo/bar
    server.use(restify.plugins.acceptParser(server.acceptable))
    server.use(restify.plugins.queryParser({mapParams: true}))  // parses query string and adds to req.query.   mapParams: true means that they are also added to req.params
    server.use(restify.plugins.bodyParser({mapParams: true}))   // parses body and adds to req.body.            mapParams: true means that they are also added to req.params
    server.use(restify.plugins.authorizationParser())
    //server.use(restify.gzipResponse())

    // Enable Cross-Origin Resource Sharing (CORS)
    CORS(server, {
        origins: config.server.allowOrigin ? config.server.allowOrigin : false,
        headers: ["*"],
        exposeHeaders: ["*"]
    })


    // TODO move this to an external file
    // Do some header stuff and process the session.  If they have a session token, validate it and attach the associated user data to the request.
    //    In the server routes, requireAuth checks for this user data.
    server.pre(async function (req, res) {
        // Return some headers
        if (!res.getHeader("Server")) res.setHeader("Server", res.serverName)
        if (res.version && !res.getHeader("X-Api-Version")) res.setHeader("X-Api-Version", res.version)
        if (!res.getHeader("X-Request-Id")) res.setHeader("X-Request-Id", req.getId())

        // Load the locale for the user
        req.userLocale = LDIntl.userLocale(req)

        // Initialize session
        const token = req.header("X-Session-Token", "")

        const sessionData = await session.init(token)

        if (!sessionData) {
            return
        }

        const refreshSuccess = await session.refreshIfNeeded(res, token, sessionData.device, sessionData.deviceId, sessionData.disableRefresh, sessionData.passthrough)

        if (!refreshSuccess) {
            return
        }

        req.sessionDevice = sessionData.device || 0
        req.sessionDeviceId = sessionData.deviceId || undefined

        req.userId = sessionData.userId

        let userData
        try {
            userData = await User.findById(req.userId).populate("masterAccount fields permissions") // Won't do anything if the field is empty
        } catch (err) {
            const error = new Error(`Error while initializing session for user ${req.userId}`, {cause: err})
            logger.error(error)
            return error
        }

        // Subaccounts
        if (userData && !userData.isMaster && userData.masterAccount) {
            const masterAccount = userData.masterAccount || {}
            req.masterAccountData = masterAccount

            // Update userData.pools with data from master account
            // This will be saved if it ever happened that user.save() is called, but it's not important
            if (userData.accessAllPools && masterAccount.pools) {
                userData.pools = masterAccount.pools || []
            }
        }

        req.userData = userData

        return
        // TODO: use caching (see https://github.com/hapijs/catbox )
    })

    // Routing
    require("./routes")(server)
    require("./routesWithHandlers")(server)

    // MongoDB connection
    logger.info(`mongoose connection readyState ${mongoose.connection.readyState}`)
    if (mongoose.connection.readyState === 0) {
        try {
            logger.info("mongoose connecting...")
            await mongoose.connect(config.mongodb.url, config.mongodb.options)
            logger.info(`mongoose connection readyState ${mongoose.connection.readyState}`)
        } catch (err) {
            const error = new Error("Api server could not connect to MongoDB when starting up", {cause: err})
            logger.error(error)
            throw error
        }
    }

    // Log all requests
    const formatMethod = method => method + " ".repeat(8 - method.length) 
    // this fires before the 'pre' handlers run, so it won't be populated with any user or session data
    //   the only real reason to log this is that its the absolute first thing that happens when the restify server receives a request,
    //   so if requests aren't getting through, its useful to see if this fires or not, to check if they're making it to restify.
    server.on("pre", function (req, res) {
        const timestamp = (new Date()).toISOString()
        const method = formatMethod(req.method)
        const path = req.url.split("?")[0]
        const user = req.userData?.email || req.headers["x-session-token"] || ""

        const logString = ` ${timestamp}\tpre:         ${method}\t${path}\t${user}`
        logger.debug(logString)
    })
    // This is going to have all the stuff populated like the user and device, but fires before the route runs
    server.on("routed", function (req, res, route) {
        const timestamp = (new Date()).toISOString()
        const method = formatMethod(req.method)
        const path = req.path()
        const user = req.userData?.email || req.headers["x-session-token"] || ""
        const device = req.sessionDevice || " "

        const logString = ` ${timestamp}\trouted:      ${method}\t${path}\t${user}\t${device}`
        logger.verbose(logString)
    })
    // This fires after the route runs (if it is not an async handler, next() must be called), and includes the result
    server.on("after", function (req, res, route, error) {
        const timestamp = (new Date()).toISOString()
        const method = formatMethod(req.method)
        const path = req.path()
        const user = req.userData?.email || req.headers["x-session-token"] || ""
        const device = req.sessionDevice || " "
        const statusCode = error ? error.toString() : res.statusCode
        
        const logString = ` ${timestamp}\tafter:       ${method}\t${path}\t${user}\t${device}\t${statusCode}`
        logger.verbose(logString)
    })

    // Docs
    if (fs.readdirSync(__dirname + "/../").includes("serverTree.txt")) {
        fs.unlinkSync(__dirname + "/../serverTree.txt")
    }
    fs.writeFileSync(__dirname + "/../serverTree.txt", server.router.toString())

    if (fs.readdirSync(__dirname + "/../").includes("serverRoutes.txt")) {
        fs.unlinkSync(__dirname + "/../serverRoutes.txt")
    }

    const allRoutes = server.router.getRoutes()
    let routesString = ""
    for (const routeId in allRoutes) {
        const route = allRoutes[routeId]
        // for debugging - breakpoint the console.log() to see functions that don't have names
        // for (const f of route.chain._stack) {
        //     if (!f.name) {
        //         console.log()
        //     }
        // }
        routesString += route.method + " " + route.path + " " + route.chain._stack.map(f => f.name).join("->") + "\n" 
    }
    fs.writeFileSync(__dirname + "/../serverRoutes.txt", routesString)

    // Start the server
    server.listen(config.server.port, function () {
        logger.info(`${server.name} listening on port ${config.server.port}`)

        // Check if we need to drop root permissions
        if (config.server.runAs) {
            if (process.getuid()) {
                // Not running as root
                logger.error("Not running as root; will not change user and group")
            
            } else {
                // Running as root; remove privileges
                process.setgid(config.server.runAs.group) // First change group, then user
                process.setuid(config.server.runAs.user)
            }
        }

        if (callback) {
            callback()
        }
    })

    // Nice exit handling (logs uncaught errors!)
    // Taken from: https://blog.heroku.com/best-practices-nodejs-errors
    const exitHandler = (code, reason) => (err, promise) => {
        if (err && err instanceof Error) {
            logger.error(new Error(`exitError ${code}: ${reason}`, {cause: err}))
        }

        server.close(code => process.exit(code))  // attempt graceful shutdown
        setTimeout(code => process.exit(code), 500).unref()  /* if not shutdown in 0.5 seconds, just kill it (unref detaches the reference to this timer,
                                                                which would normally keep the process open, so that server.close() can kill the process itself) */
    }
    process.on("uncaughtException", exitHandler(1, "Unexpected Error"))
    process.on("unhandledRejection", exitHandler(1, "Unhandled Promise"))
    process.on("SIGTERM", exitHandler(0, "SIGTERM"))
    process.on("SIGINT", exitHandler(0, "SIGINT"))
}

module.exports = apiServerStart